
# Problem: Compute self-gravity using FMM
# Author:  Ryan Golant (ryan.golant@columbia.edu)
#
# July 19, 2022

#======================================================================
# PROBLEM DEFINITION
#======================================================================

 Domain {
     lower = [ 0.0, 0.0, 0.0 ];
     # upper = [ 3.0, 1.5, 1.5 ];
     upper = [1.0, 1.0, 1.0];
 }


 Initial {
    list = ["value"];

    value {
        # density = [ 1.0 ];
        density = [1.000001, x >= 0.5, 0.999999];
	
	acceleration_x = [ 0.0 ];
	acceleration_y = [ 0.0 ];
	acceleration_z = [ 0.0 ];
    }
 }


 Boundary {

     # type = "reflecting";
     type = "periodic";
 }

 Stopping {
     cycle = 1;
    # time = 0.10000;
 }

 Physics {
      list = ["gravity"];

      gravity {
      	 grav_const_codeU = 0.25 * pi;
      }
  
 }

#======================================================================
# DISCRETIZATION
#======================================================================

 Mesh {
     root_rank = 3;
    #  root_size   = [ 64, 32, 1];  # total number of cells in root grid
      root_size = [32, 32, 32];
     root_blocks = [  1,  1, 1 ];  # number of blocks in root grid
                                # (so block size = (64/4,32/2) = (16,16)
 }

 Adapt {
     list = [ "density" ];
     # list = [ "slope" ];
     
     max_level = 0;

     density {
         field_list = [ "density" ];
         max_coarsen = 0.00;
         min_refine = 0.0009;
         type = "density";
	    # type = "slope";
     }
 }

 Field {
     alignment = 8;
     gamma = 1.4000;
     ghost_depth = 1;
     
     list = [ "density", "acceleration_x", "acceleration_y", "acceleration_z"];
     
     padding = 0;
 }

 '''
 Particle {
    list = ["star", "trace"];

    star {
        attributes = [ "x", "double",
                       "y", "double",
                       "z", "double",
                       "ax", "double",
                       "ay", "double",
                       "az", "double",
                       "mass", "double"];
                       
        position = [ "x", "y", "z" ];
        
        group_list = ["is_gravitating"];
    }

    trace {
        attributes = [ "x", "double",
                       "y", "double",
                       "z", "double",
                       "ax", "double",
                       "ay", "double",
                       "az", "double"];
                       
        position = [ "x", "y", "z" ];
    }
  }
  '''

#======================================================================
# COMPUTATION
#======================================================================

 Method {

     # "multipole": compute gravitational acceleration using FMM

     list = [ "multipole" ];

     multipole {
         
	 theta = 0.0001;
	 eps0 = 0.0;
	 r0 = 0.0;
	 interp_xpoints = 64;
	 interp_ypoints = 64;
	 interp_zpoints = 64;
     }
 }

#======================================================================
# OUTPUT
#======================================================================

 Output {
    list = [];    
 }
